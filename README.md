## Description

Example of a simple web application with a API rate limiter based on the [sliding window](https://en.wikipedia.org/wiki/Sliding_window_protocol) strategy, using a Redis cache instead of the Nest.js default throttle guard.

It uses a middleware to intercept the request and check if the user has exceeded the limit of requests, if so, it returns a 429 status code.

The rate limit is based on the user IP address for public routes and a API token for private routes.

There is an API Key authentication guard that checks if the API token is valid.
It uses a mocked database to check if the API token is among the registered ones.

There are  2 sets of routes:
- Public routes: `/public/a`, `/public/b`, `/public/c`. These routes do not require authentication and measure rate limit per ip address.
- Private routes: `/private/a`, `/private/b`, `/private/c`. These routes require authentication via API Key in request header and measure rate limit per API Key.

Each route has a different weight to calculate the rate limit. These weights are defined in the `public.routes.ts` and `private.routes.ts` files inside each module.

Weights are stored in a Redis key with the following format: `rate-limit:{token}:{uuid}`, where `token` is the API token or the IP address and `uuid` is an autogenerated UUID.

## Installation

```bash
# install dependencies
$ npm install

# initialize redis cache server
$ docker-compose up -d

# e2e tests
$ npm run test:e2e

# running the app
$ npm run start
```
